---
title: 'Managing Secrets'
description: 'Create and manage secrets with External Secrets and AWS Secrets Manager'
icon: 'key'
---

## Overview

The kit uses [External Secrets Operator](https://external-secrets.io/) to sync secrets from AWS Secrets Manager into Kubernetes. This keeps sensitive data out of Git while providing a GitOps-friendly secret management workflow.

## Architecture

```
AWS Secrets Manager          Kubernetes Cluster
+-------------------+        +----------------------------+
|                   |        |                            |
| staging/myapp/    |        |  ClusterSecretStore        |
|   database-url    |<-------|  (aws-secrets-manager)     |
|                   |        |            |               |
+-------------------+        |            v               |
                             |  ExternalSecret            |
                             |  (myapp-secrets)           |
                             |            |               |
                             |            v               |
                             |  Secret                    |
                             |  (myapp-secrets)           |
                             |                            |
                             +----------------------------+
```

1. **ClusterSecretStore** - Configures access to AWS Secrets Manager (one per cluster)
2. **ExternalSecret** - Defines which secrets to fetch and how to map them
3. **Secret** - The Kubernetes Secret created and kept in sync

## Prerequisites

The External Secrets Operator uses Pod Identity to authenticate to AWS. This is configured automatically by the EKS Terraform module.

Verify the ClusterSecretStore is working:

```bash
kubectl get clustersecretstores
kubectl describe clustersecretstore aws-secrets-manager
```

## Create a Secret in AWS

<Steps>
  <Step title="Create the secret in Secrets Manager">
    Using AWS CLI:

    ```bash
    aws secretsmanager create-secret \
      --name "staging/myapp/database-url" \
      --secret-string "postgres://user:pass@host:5432/db" \
      --region us-east-2
    ```

    Or using the AWS Console:
    1. Navigate to Secrets Manager
    2. Click "Store a new secret"
    3. Choose "Other type of secret"
    4. Enter key/value pairs or plaintext
    5. Name it following the pattern: `{environment}/{app}/{secret-name}`
  </Step>

  <Step title="Create the ExternalSecret manifest">
    Create `ExternalSecret.myapp-secrets.yaml` in your service's templates:

    ```yaml
    apiVersion: external-secrets.io/v1
    kind: ExternalSecret
    metadata:
      name: myapp-secrets
      namespace: myapp
    spec:
      refreshInterval: 1h
      secretStoreRef:
        name: aws-secrets-manager
        kind: ClusterSecretStore
      target:
        name: myapp-secrets
        creationPolicy: Owner
      data:
        - secretKey: DATABASE_URL
          remoteRef:
            key: staging/myapp/database-url
    ```
  </Step>

  <Step title="Deploy and verify">
    ```bash
    # Apply the ExternalSecret
    kubectl apply -f ExternalSecret.myapp-secrets.yaml

    # Check the ExternalSecret status
    kubectl get externalsecret myapp-secrets -n myapp

    # Verify the Secret was created
    kubectl get secret myapp-secrets -n myapp
    kubectl get secret myapp-secrets -n myapp -o jsonpath='{.data.DATABASE_URL}' | base64 -d
    ```
  </Step>
</Steps>

## Secret Naming Conventions

Use a consistent naming pattern for secrets in AWS Secrets Manager:

```
{environment}/{application}/{secret-name}
```

Examples:
- `staging/go-backend/database-url`
- `production/go-backend/database-url`
- `staging/argocd/github-oauth-client-secret`

This makes it easy to:
- Identify which environment a secret belongs to
- Control access with IAM policies
- Avoid naming conflicts

## Fetch Multiple Values from One Secret

AWS Secrets Manager secrets can contain JSON with multiple key/value pairs:

<Steps>
  <Step title="Create a JSON secret">
    ```bash
    aws secretsmanager create-secret \
      --name "staging/myapp/config" \
      --secret-string '{"DB_HOST":"localhost","DB_USER":"admin","DB_PASS":"secret"}' \
      --region us-east-2
    ```
  </Step>

  <Step title="Extract specific keys">
    ```yaml
    apiVersion: external-secrets.io/v1
    kind: ExternalSecret
    metadata:
      name: myapp-config
      namespace: myapp
    spec:
      refreshInterval: 1h
      secretStoreRef:
        name: aws-secrets-manager
        kind: ClusterSecretStore
      target:
        name: myapp-config
      data:
        - secretKey: DB_HOST
          remoteRef:
            key: staging/myapp/config
            property: DB_HOST
        - secretKey: DB_USER
          remoteRef:
            key: staging/myapp/config
            property: DB_USER
        - secretKey: DB_PASS
          remoteRef:
            key: staging/myapp/config
            property: DB_PASS
    ```
  </Step>
</Steps>

## Use Secrets in Pods

Reference the synced Secret in your Deployment:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
        - name: myapp
          env:
            # Single environment variable
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: myapp-secrets
                  key: DATABASE_URL

            # Or load all keys as env vars
          envFrom:
            - secretRef:
                name: myapp-config
```

## Refresh and Sync Behavior

### Automatic Refresh

ExternalSecrets periodically refresh from AWS based on `refreshInterval`:

```yaml
spec:
  refreshInterval: 1h  # Check for updates every hour
```

### Force Refresh

To immediately sync a secret:

```bash
# Delete and recreate the ExternalSecret
kubectl delete externalsecret myapp-secrets -n myapp
kubectl apply -f ExternalSecret.myapp-secrets.yaml

# Or annotate to trigger refresh
kubectl annotate externalsecret myapp-secrets -n myapp force-sync=$(date +%s)
```

### Reloader Integration

The kit includes [Reloader](https://github.com/stakater/Reloader), which automatically restarts pods when their Secrets change:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  annotations:
    reloader.stakater.com/auto: "true"  # Restart on any Secret/ConfigMap change
```

Or for specific secrets:

```yaml
metadata:
  annotations:
    secret.reloader.stakater.com/reload: "myapp-secrets"
```

## Environment-Specific Secrets

Use different secret paths for each environment:

```yaml
# values.yaml
secrets:
  databaseUrlKey: staging/myapp/database-url

# values.production.yaml
secrets:
  databaseUrlKey: production/myapp/database-url
```

Then template the ExternalSecret:

```yaml
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: myapp-secrets
spec:
  data:
    - secretKey: DATABASE_URL
      remoteRef:
        key: {{ .Values.secrets.databaseUrlKey }}
```

## IAM Permissions

The External Secrets service account needs permission to read secrets. This is configured via Pod Identity in the EKS Terraform module.

To add access to new secret paths, update the IAM policy:

```hcl
# terraform/modules/eks/main.tf
resource "aws_iam_policy" "external_secrets" {
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "secretsmanager:GetSecretValue",
          "secretsmanager:DescribeSecret"
        ]
        Resource = [
          "arn:aws:secretsmanager:us-east-2:*:secret:staging/*",
          "arn:aws:secretsmanager:us-east-2:*:secret:production/*"
        ]
      }
    ]
  })
}
```

## Troubleshooting

### ExternalSecret shows "SecretSyncedError"

1. Check the ExternalSecret status:
   ```bash
   kubectl describe externalsecret myapp-secrets -n myapp
   ```

2. Common causes:
   - Secret doesn't exist in AWS Secrets Manager
   - IAM permissions missing
   - Wrong secret path or property name

### "AccessDeniedException" in logs

The Pod Identity role lacks permissions:

1. Verify the service account annotation:
   ```bash
   kubectl get sa external-secrets -n external-secrets -o yaml
   ```

2. Check the IAM role policy includes the secret path

### Secret not updating in pods

1. Verify the Secret was updated:
   ```bash
   kubectl get secret myapp-secrets -n myapp -o yaml
   ```

2. Check if Reloader is enabled:
   ```bash
   kubectl get deployment myapp -n myapp -o yaml | grep reloader
   ```

3. Force a pod restart:
   ```bash
   kubectl rollout restart deployment myapp -n myapp
   ```

## Best Practices

1. **Use namespaced paths** - Include environment and app name in secret paths
2. **Set appropriate refresh intervals** - Balance freshness vs. API costs
3. **Use Reloader** - Automatically restart pods when secrets change
4. **Avoid storing in Git** - Never commit actual secret values, only ExternalSecret manifests
5. **Rotate regularly** - Use AWS Secrets Manager rotation for database credentials

## Next Steps

- [Database Operations](/usage/operations/07-database-operations) - Manage database credentials
- [Bootstrapping a New Service](/usage/operations/04-bootstrapping-new-service) - Add secrets for new services
