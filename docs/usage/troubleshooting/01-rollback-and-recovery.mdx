---
title: 'Rollback & Recovery'
description: 'Roll back deployments and recover from incidents'
icon: 'rotate-left'
---

## Overview

This guide covers rollback procedures for different types of failures. The key principle is: **roll forward when possible, roll back when necessary**.

## Application Rollback

### Via ArgoCD (Recommended)

ArgoCD maintains deployment history for quick rollbacks:

```bash
# View deployment history
argocd app history <app-name>

# Rollback to previous revision
argocd app rollback <app-name>

# Rollback to specific revision
argocd app rollback <app-name> <revision>
```

<Note>
ArgoCD rollback reverts to the previous sync state. If auto-sync is enabled, it will sync again on the next interval. Consider disabling auto-sync during investigation.
</Note>

### Via GitOps

For a permanent rollback, update the image tag in Git:

<Steps>
  <Step title="Find the previous working version">
    ```bash
    # Check git history for image tag changes
    git log --oneline -20 -- kubernetes/src/services/go-backend-helm/values.yaml
    
    # Or check ECR for available tags
    aws ecr describe-images --repository-name services/go-backend \
      --query 'imageDetails[*].imageTags' --output table
    ```
  </Step>

  <Step title="Update the image tag">
    Edit `kubernetes/src/services/go-backend-helm/values.yaml`:

    ```yaml
    image:
      version: 0.2.1  # Previous working version
    ```
  </Step>

  <Step title="Render and push">
    ```bash
    mise run //kubernetes/src/services:render-all
    git add .
    git commit -m "fix: rollback go-backend to 0.2.1"
    git push origin main
    ```
  </Step>
</Steps>

### Via kubectl (Emergency)

For immediate rollback without waiting for GitOps:

```bash
# Rollback to previous revision
kubectl rollout undo deployment/<name> -n <namespace>

# Rollback to specific revision
kubectl rollout undo deployment/<name> -n <namespace> --to-revision=2

# Check rollout status
kubectl rollout status deployment/<name> -n <namespace>
```

<Warning>
kubectl rollback will be overwritten on the next ArgoCD sync. Use this only for emergencies, then follow up with a GitOps rollback.
</Warning>

## Infrastructure Component Rollback

### Via ArgoCD

```bash
# View history
argocd app history traefik

# Rollback
argocd app rollback traefik
```

### Via Git

Revert the chart version change:

```bash
# Find the commit that updated the version
git log --oneline -10 -- kubernetes/src/infrastructure/traefik/

# Revert the commit
git revert <commit-hash>
git push origin main
```

Or manually update values.yaml to the previous version:

```yaml
chartVersions:
  traefik: "38.0.1"  # Previous version
```

## Terraform Rollback

### Via Git Revert

```bash
# Find the problematic commit
git log --oneline -10 -- terraform/

# Revert it
git revert <commit-hash>
git push origin main
```

The CI/CD pipeline will run `terraform apply` with the reverted configuration.

### Manual State Recovery

If Terraform state is corrupted:

<Steps>
  <Step title="Set environment variables">
    ```bash
    export REGION="us-east-2"  # Your AWS region
    # State bucket follows pattern: <namespace>-gbl-infra-bootstrap-state
    # e.g., "ksk-gbl-infra-bootstrap-state" if you used "ksk" as your namespace
    export STATE_BUCKET="<namespace>-gbl-infra-bootstrap-state"
    ```
  </Step>

  <Step title="Enable versioning recovery">
    S3 bucket versioning is enabled. List previous versions:

    ```bash
    aws s3api list-object-versions \
      --bucket ${STATE_BUCKET} \
      --prefix terraform/staging/${REGION}/eks/
    ```
  </Step>

  <Step title="Restore previous state">
    ```bash
    aws s3api copy-object \
      --bucket ${STATE_BUCKET} \
      --copy-source "${STATE_BUCKET}/terraform/staging/${REGION}/eks/terraform.tfstate?versionId=<version-id>" \
      --key terraform/staging/${REGION}/eks/terraform.tfstate
    ```
  </Step>

  <Step title="Verify and plan">
    ```bash
    cd terraform
    terramate run --tags staging:${REGION}:eks -- terraform init -reconfigure
    terramate run --tags staging:${REGION}:eks -- terraform plan
    ```
  </Step>
</Steps>

## Database Recovery

### Point-in-Time Recovery (CloudNativePG)

If continuous backup is configured:

```yaml
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: myapp-cluster-recovered
spec:
  instances: 3
  
  bootstrap:
    recovery:
      source: myapp-cluster
      recoveryTarget:
        targetTime: "2024-01-15T10:30:00Z"  # Recover to this point
  
  externalClusters:
    - name: myapp-cluster
      barmanObjectStore:
        destinationPath: s3://myapp-backups/
        s3Credentials:
          accessKeyId:
            name: aws-creds
            key: ACCESS_KEY_ID
          secretAccessKey:
            name: aws-creds
            key: SECRET_ACCESS_KEY
```

### Restore from Backup

```bash
# List available backups
kubectl get backups -n myapp

# Create a new cluster from backup
kubectl apply -f - <<EOF
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: myapp-cluster-restored
  namespace: myapp
spec:
  instances: 3
  bootstrap:
    recovery:
      backup:
        name: myapp-backup-20240115
EOF
```

### Migration Rollback

Create a new "down" migration:

```sql
-- migrations/20240116000000_rollback_previous.sql
-- Reverse the changes from the previous migration
DROP INDEX IF EXISTS "users_email_idx";
ALTER TABLE "users" DROP COLUMN IF EXISTS "email";
```

## Incident Response Checklist

### 1. Assess Impact

- [ ] Identify affected services
- [ ] Determine user impact
- [ ] Check monitoring dashboards
- [ ] Review recent deployments

### 2. Stabilize

- [ ] Rollback if clear cause identified
- [ ] Scale up resources if needed
- [ ] Disable auto-sync if investigating
- [ ] Communicate status to stakeholders

### 3. Investigate

- [ ] Check application logs
- [ ] Review ArgoCD sync history
- [ ] Check recent Git commits
- [ ] Review Terraform changes

### 4. Resolve

- [ ] Apply fix or confirm rollback
- [ ] Verify services are healthy
- [ ] Re-enable auto-sync
- [ ] Update monitoring/alerts if needed

### 5. Post-Incident

- [ ] Document timeline and actions
- [ ] Identify root cause
- [ ] Create follow-up issues
- [ ] Update runbooks

## Disable Auto-Sync During Incidents

To prevent ArgoCD from overwriting manual fixes:

```bash
# Disable auto-sync for an application
argocd app set <app-name> --sync-policy none

# Re-enable after resolution
argocd app set <app-name> --sync-policy automated
```

Or patch the Application:

```bash
kubectl patch application <app-name> -n argocd --type merge -p '{"spec":{"syncPolicy":null}}'
```

## Recovery Runbooks

### Complete Cluster Recovery

If the EKS cluster is destroyed:

1. **Restore Terraform state** (if corrupted)
2. **Reapply infrastructure**
   ```bash
   terramate run --tags staging:infrastructure -- terraform apply
   ```
3. **Bootstrap ArgoCD**
   ```bash
   kubectl apply -f kubernetes/rendered/staging/argocd/argocd/
   ```
4. **Wait for sync** - ArgoCD will restore all applications

### Namespace Recovery

If a namespace is accidentally deleted:

```bash
# ArgoCD will recreate it on next sync
argocd app sync <app-name> --prune

# Or manually recreate and sync
kubectl create namespace <namespace>
argocd app sync <app-name>
```

### Secret Recovery

If secrets are deleted:

1. ExternalSecrets will recreate them automatically on next refresh
2. Force immediate refresh:
   ```bash
   kubectl annotate externalsecret <name> -n <namespace> force-sync=$(date +%s)
   ```

## Prevention

### GitOps Best Practices

1. **Require PR reviews** for all changes
2. **Use protected branches** for main
3. **Run plan checks** before merge
4. **Tag releases** for easy rollback reference

### Monitoring

1. **Set up alerts** for deployment failures
2. **Monitor error rates** after deployments
3. **Use canary deployments** for critical services
4. **Implement feature flags** for gradual rollout

### Backup Strategy

1. **Enable S3 versioning** for Terraform state
2. **Configure CloudNativePG backups** for databases
3. **Document recovery procedures** in runbooks
4. **Test recovery regularly** in non-production
