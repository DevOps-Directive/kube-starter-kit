---
title: "Terraform Automation with Digger"
description: "GitHub-integrated Terraform CI/CD, plan and apply via PR comments"
icon: "robot"
---

## The Problem

Running Terraform locally works fine when you're a team of one, but it quickly becomes a liability as you grow:

- **"Who ran that apply?":** Without centralized execution, it's hard to track who changed what and when. Your state file says it changed, but good luck figuring out the context.
- **No visibility before merge:** You want to review infrastructure changes before they happen, but `terraform plan` output buried in a CI log isn't exactly reviewer-friendly.
- **Credential sprawl:** Every developer with Terraform access needs AWS credentials. That's a lot of long-lived secrets floating around laptops.
- **State lock conflicts:** Two people running `terraform apply` at the same time leads to a bad day.
- **Context switching:** Running plan locally, copying output to PR comments, waiting for approval, then running apply... it's tedious and error-prone.

## How Kube Starter Kit Addresses This

I've integrated [Digger](https://digger.dev) into the kit to bring Terraform into your existing GitHub workflow:

**Plan on every PR:** When you open a pull request that touches Terraform code, Digger automatically runs `terraform plan` and posts the output as a PR comment. Reviewers see exactly what will change before approving.

**Apply via PR comment:** When you're ready to apply, comment `digger apply` on the PR. Digger runs `terraform apply` and posts the results. The change is applied and verified before you merge, no surprises after the fact.

**GitHub checks enforced:** Applies require the PR to be mergeable (passing CI, approvals met, no conflicts). You can't apply changes that haven't passed review.

**Keyless authentication:** Digger uses GitHub OIDC to assume an AWS role. No long-lived credentials stored in GitHub secrets. The trust relationship is explicit: only workflows from your repository can assume the role.

**Automatic project discovery:** Digger scans your `terraform/live` directory and automatically creates projects for each Terragrunt configuration. Add a new environment or region, and Digger picks it up.

**Locking built-in:** Digger coordinates runs so you don't get concurrent applies stepping on each other.

## What's Included

### Digger Configuration

The `digger.yml` at the root of the repository defines how Digger discovers and runs your Terraform:

```yaml
workflows:
  default:
    plan:
      steps:
        - init
        - plan
    apply:
      steps:
        - init
        - apply
    workflow_configuration:
      on_pull_request_pushed: ["digger plan"]
      on_pull_request_closed: ["digger unlock"]
      on_commit_to_default: ["digger unlock"]

generate_projects:
  blocks:
    - include: "terraform/live/*/*/**"
      exclude: "**/.terraform/**"
      terragrunt: true
      workflow: "default"
      include_patterns:
        - terraform/modules/**  # Re-plan when modules change
        - digger.yml
```

### GitHub Actions Workflow

The workflow handles AWS authentication via OIDC and runs Digger with the right tool versions:

```yaml
- name: "Configure AWS Credentials"
  uses: aws-actions/configure-aws-credentials@v4
  with:
    aws-region: us-east-2
    role-to-assume: arn:aws:iam::YOUR_ACCOUNT:role/github-oidc

- uses: diggerhq/digger@v0.6
  with:
    setup-terraform: true
    terraform-version: 1.13.3
    setup-terragrunt: true
    terragrunt-version: 0.90.0
    upload-plan-destination: aws  # Store plans in S3
```

### What the Workflow Looks Like

<Steps>
  <Step title="Open a PR">
    Make changes to any Terraform code—modules or live configurations.
  </Step>
  <Step title="Automatic Plan">
    Digger detects affected projects and runs `terraform plan` for each. Results appear as PR comments.
  </Step>
  <Step title="Review">
    Reviewers see exactly what infrastructure changes will happen. No surprises.
  </Step>
  <Step title="Apply">
    Once the PR is approved and mergeable, comment `digger apply`. Digger applies the changes and posts results.
  </Step>
  <Step title="Merge">
    With changes already applied and verified, merge the PR to keep Git in sync with infrastructure state.
  </Step>
  <Step title="Audit Trail">
    Every change is tied to a PR with full context: who requested it, who approved it, what changed.
  </Step>
</Steps>

## Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| **Digger over Atlantis/Spacelift/Terraform Cloud** | Digger runs in your own GitHub Actions—no external service to trust with your AWS credentials or state. Simpler to set up, easier to understand, lower cost. |
| **Apply before merge (not on merge)** | You see the actual apply result before merging. If something fails, the PR stays open and Git reflects reality. No broken state from failed post-merge applies. |
| **Mergeable check required** | Applies can't happen until CI passes and approvals are in place. Prevents applying untested or unreviewed changes. |
| **OIDC over static credentials** | No secrets to rotate. The trust is based on GitHub's identity, not a shared secret. |
| **Plan storage in S3** | Plans are stored in your own S3 bucket, not a third-party service. You control the data. |
| **Auto-discovery over explicit project list** | Adding a new environment shouldn't require updating CI configuration. Convention over configuration. |

