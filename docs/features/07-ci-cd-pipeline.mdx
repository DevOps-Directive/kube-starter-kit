---
title: "CI/CD Pipelines"
description: "Automated container builds and staging deployments on every merge to main"
icon: "arrows-spin"
---

## The Problem

Getting code from a developer's machine to a running environment shouldn't require tribal knowledge:

- **Manual build processes:** Someone has to remember to build the container, tag it correctly, push it to the registry, and update the deployment manifests.
- **Inconsistent builds:** "Works on my machine" extends to container images when builds happen locally with different Docker versions, cached layers, and environment variables.
- **Deploying everything on every change:** A monorepo with multiple services shouldn't rebuild and redeploy everything when only one service changed.
- **Environment drift:** Staging falls behind because deployments are manual and tedious.

## How Kube Starter Kit Addresses This

I've implemented a GitHub Actions workflow that automates the entire build-to-staging pipeline:

**Automatic change detection:** The pipeline detects which applications actually changed and only builds those. Update your Go backend? Only the Go backend builds. Touch a shared library? Everything that depends on it rebuilds.

**Consistent container builds:** Every build happens in the same CI environment with the same tooling. No more "it built fine on my laptop."

**Rendered manifests pattern:** Rather than templating at deploy time, the pipeline renders Kubernetes manifests and commits them to Git. What's in the repository is exactly what ArgoCD deploys.

**Staging on every merge:** When your PR merges to main, staging automatically gets the new version. No manual steps, no forgetting to deploy.

## What's Included

### Workflow Structure

```
.github/workflows/
└── build-deploy.yaml    # Main CI/CD workflow
```

### Change Detection

The workflow uses path filters to determine what needs building:

```yaml
on:
  push:
    branches: [main]
    paths:
      - 'applications/**'
      - 'kubernetes/src/**'

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      go-backend: ${{ steps.filter.outputs.go-backend }}
      # Add more applications here
    steps:
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            go-backend:
              - 'applications/go-backend/**'
```

Only changed applications proceed to the build stage. This keeps CI fast and avoids unnecessary container registry bloat.

### Build Process

<Steps>
  <Step title="Checkout code">
    Pull the repository at the merge commit.
  </Step>
  <Step title="Detect changes">
    Determine which applications have modifications.
  </Step>
  <Step title="Build containers">
    For each changed application, build and push a container image tagged with the commit SHA.
  </Step>
  <Step title="Render manifests">
    Generate Kubernetes manifests for staging with the new image tags.
  </Step>
  <Step title="Commit rendered manifests">
    Push the updated manifests to the repository.
  </Step>
  <Step title="ArgoCD syncs">
    ArgoCD detects the manifest changes and deploys to staging automatically.
  </Step>
</Steps>

### Container Registry

Images are pushed to Amazon ECR with commit-based tags:

```
<account>.dkr.ecr.<region>.amazonaws.com/go-backend:abc123f
```

Using commit SHAs as tags provides:
- **Traceability:** Every running container maps to an exact commit
- **Immutability:** Tags are never overwritten
- **Easy rollback:** Revert to a previous commit and the old image is still there

### Manifest Rendering

The pipeline renders Helm charts or Kustomize overlays into plain Kubernetes manifests:

```
kubernetes/
├── src/
│   └── services/
│       └── go-backend/
│           ├── Chart.yaml
│           └── values.yaml
└── rendered/
    └── staging/
        └── services/
            └── go-backend/
                └── manifests.yaml  # Generated by CI
```

This "rendered manifests" approach means:
- **No runtime surprises:** What you see in Git is exactly what deploys
- **Easy diffing:** PRs show the actual Kubernetes changes, not just Helm value tweaks
- **Auditable:** Git history shows exactly what was deployed when

### GitHub OIDC Authentication

The workflow authenticates to AWS without long-lived credentials:

```yaml
- name: Configure AWS credentials
  uses: aws-actions/configure-aws-credentials@v4
  with:
    role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
    aws-region: us-east-2
```

GitHub's OIDC provider exchanges a short-lived token for AWS credentials. No access keys to rotate or leak.

## Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| **Change detection with path filters** | Fast CI, minimal rebuilds, less registry storage. In a monorepo, you don't want every commit to rebuild every service. |
| **Commit SHA tags** | Immutable, traceable, and rollback-friendly. Avoids the "what's actually in `latest`?" problem. |
| **Rendered manifests in Git** | Eliminates runtime templating surprises. ArgoCD deploys exactly what's committed. |
| **Staging auto-deploy on merge** | Reduces friction for testing. If it's merged, it's in staging. Teams can always see current main in a real environment. |
| **GitHub OIDC over access keys** | No credentials to manage or rotate. Tokens are scoped and short-lived. |
