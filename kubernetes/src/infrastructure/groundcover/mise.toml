[env]
OUTPUT_PATH = "infrastructure/groundcover"

[tasks.render-cluster]
description = "Render manifests for specified cluster"
usage = '''
arg "<cluster>" help="Target cluster" {
  choices "staging" "production"
}
'''
run = """
#!/usr/bin/env bash
set -euo pipefail

export OUTPUT_DIR="${PWD}/../../../rendered/${usage_cluster}/${OUTPUT_PATH}"

mise run //tools:render:prep-output-dir "${OUTPUT_DIR}"

helm template --release-name groundcover . \
  --namespace groundcover \
  --values values.yaml \
  --values values.${usage_cluster}.yaml \
  | mise run //tools:render:split-k8s-docs ${OUTPUT_DIR}

# Remove rendered Secrets, but keep the non-sensitive config secret
shopt -s nullglob
for f in "${OUTPUT_DIR}"/v1_secret_*; do
  [[ "$(basename "$f")" == "v1_secret_groundcover_groundcover-config.yaml" ]] && continue
  rm -f -- "$f"
done
shopt -u nullglob
"""

[tasks.k8s-secret-to-aws]
description = "Convert a Kubernetes Secret YAML into an AWS Secrets Manager JSON secret and write an ExternalSecret manifest"
usage = '''
arg "<secret_yaml>" help="Path to Kubernetes Secret manifest (yaml) (interpreted relative to your current working directory)"
arg "[aws_secret_name]" help="AWS Secrets Manager secret name/id (default: ksk-use2-staging-eks-groundcover-NAME)"
flag "--region <aws_region>" help="AWS region for Secrets Manager operations" default="us-east-2"
'''
run = '''
#!/usr/bin/env bash
set -euo pipefail

# Resolve the caller's cwd (where you ran `mise run ...`) and build an absolute path
CALLER_CWD="{{cwd}}"

INPUT="${usage_secret_yaml}"
if [[ "$INPUT" = /* ]]; then
  FILE="$INPUT"
else
  FILE="${CALLER_CWD}/${INPUT}"
fi

AWS_REGION="${usage_region}"

for c in yq jq aws base64; do
  command -v "$c" >/dev/null 2>&1 || { echo "missing required command: $c" >&2; exit 1; }
done

NAME="$(yq -r '.metadata.name' "$FILE")"
NS="$(yq -r '.metadata.namespace // "default"' "$FILE")"
TYPE="$(yq -r '.type // "Opaque"' "$FILE")"

AWS_SECRET_NAME="${usage_aws_secret_name:-ksk-use2-staging-eks-groundcover-${NAME}}"

JSON="$(
  yq -o=json '.' "$FILE" \
  | jq -c '
      def b64d: @base64d;
      (.stringData // {}) as $s
      | (.data // {} | with_entries(.value |= (try (. | b64d) catch .))) as $d
      | ($s + $d)
    '
)"

if aws --region "$AWS_REGION" secretsmanager describe-secret --secret-id "$AWS_SECRET_NAME" >/dev/null 2>&1; then
  aws --region "$AWS_REGION" secretsmanager put-secret-value \
    --secret-id "$AWS_SECRET_NAME" \
    --secret-string "$JSON" >/dev/null
else
  aws --region "$AWS_REGION" secretsmanager create-secret \
    --name "$AWS_SECRET_NAME" \
    --secret-string "$JSON" >/dev/null
fi

OUT="ExternalSecret.${NAME}.yaml"
# write output to caller cwd too (so it ends up next to where you ran it)
OUT_PATH="${CALLER_CWD}/${OUT}"

cat > "$OUT_PATH" <<YAML
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: ${NAME}
  namespace: ${NS}
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: ClusterSecretStore
  target:
    name: ${NAME}
    template:
      type: ${TYPE}
  dataFrom:
    - extract:
        key: ${AWS_SECRET_NAME}
YAML

echo "wrote ${OUT_PATH}" >&2
'''
